# templates/auto-gitlab/template.yml
spec:
  inputs:
    job-prefix:
      description: "Job prefix"
      type: string
      default: "-$CI_PROJECT_ID-$CI_COMMIT_SHORT_SHA"
      
    auto-rebase:
      description: "Auto rebase source branch"
      type: boolean
      default: false
      
    auto-approve:
      description: "Auto approve merge request"
      type: boolean
      default: false
    
    auto-merge:
      description: "Auto confirm merge request"
      type: boolean
      default: false
    auto-remove-source-branch:
      description: "Auto remove source branch after merge"
      type: boolean
      default: false
      
    auto-tag:
      description: "Create auto TAG."
      type: boolean
      default: false
    auto-tag-pattern:
      description: "Validate TAG by pattern" # "/^[vV]?\\d\\.\\d+\\.\\d+$/" или /^[vV]?\d\.\d+\.\d+$/
      type: string
      default: /^[vV]?\d\.\d+\.\d+$/
    auto-tag-version-prefix:
      description: "Prefix for autogenerated tag"
      type: string
      default: ""
    auto-tag-version-major:
      type: string
      default: "0"
    auto-tag-version-minor:
      type: string
      default: "0"      
      
    auto-release:
      description: "Auto release after merge"
      type: boolean
      default: false
    dependencies-jobs:
      description: "Artifact job list"
      type: array
      default: []
    
---

include:
  - local: 'templates/-1-common-rules/template.yml'

variables: 
  AUTO_REMOVE_SOURCE_BRANCH: $[[ inputs.auto-remove-source-branch ]]
  CI_COMMIT_TAG_PATTERN: $[[ inputs.auto-tag-pattern ]]
  AUTO_TAG_VERSION_PREFIX: $[[ inputs.auto-tag-version-prefix ]]
  AUTO_TAG_VERSION_MAJOR: $[[ inputs.auto-tag-version-major ]]
  AUTO_TAG_VERSION_MINOR: $[[ inputs.auto-tag-version-minor ]]

stages:
  - auto-merge
  - auto-release
    

.gitlab-api-rebase: |
  rebase_merge_request() {
      local token="${1:?Не передан токен авторизации}"
      local iid="${2:?Не передан IID merge request}"
      local timeout="${3:-60}"   # максимальное время ожидания в секундах
      local interval=5            # интервал между проверками

      # Проверка обязательных переменных CI
      : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"

      REBASE_JSON=$(jq -n \
          '{
            "skip_ci": true
          }'
      )

      local api_url="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${iid}/rebase"

      # Запускаем rebase
      log_info "Запуск rebase для MR IID=${iid}..."
      rebase_info=$(curl -f -X PUT \
          -H "Authorization: Bearer ${token}" \
          -H "Content-Type: application/json" \
          -d "${REBASE_JSON}" \
          "${api_url}" || fail "Не удалось запустить rebase для MR IID=${iid}")

      log_info "$rebase_info"
  
      log_info "Rebase запущен, ожидаем завершения..."

      local elapsed=0
      while [ "$elapsed" -lt "$timeout" ]; do
          local local_result
          local in_progress
          local merge_error

          local_result=$(curl -s -X GET \
            -H "Authorization: Bearer ${token}" \
            --data-urlencode "include_rebase_in_progress=true" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${iid}")

          log_info "$local_result"

          in_progress=$(echo "$local_result" | jq -r '.rebase_in_progress')
          merge_error=$(echo "$local_result" | jq -r '.merge_error')

          if [[ "$in_progress" == "false" ]]; then
              if [[ "$merge_error" != "null" ]]; then
                  fail "Rebase для MR IID=${iid} завершился с ошибкой: $merge_error"
              else
                  log_info "Rebase для MR IID=${iid} завершен успешно."
                  return 0
              fi
          fi

          sleep $interval
          elapsed=$((elapsed + interval))
      done

      fail "Rebase для MR IID=${iid} не завершился за ${timeout} секунд."
  }
  
.gitlab-api-merge: |
  get_open_merge_requests() {
      local token="${1:?Не передан токен авторизации}"

      : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
      : "${CI_COMMIT_REF_NAME:?Не задана переменная CI_COMMIT_REF_NAME}"

      mr_list=$(curl -s -f -X GET \
        -H "Authorization: Bearer ${token}" \
        --data-urlencode "state=opened" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests")
  
      filtered_mr=$(echo "$mr_list" | jq --arg branch "$CI_COMMIT_REF_NAME" '[.[] | select(.source_branch==$branch)]')

      if [ -n "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" ]; then
        filtered_mr=$(echo "$filtered_mr" | jq --arg target "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" '[.[] | select(.target_branch==$target)]')
      fi

      echo "$filtered_mr"
  }

  create_merge_request() {
    local token="${1:?Не передан токен авторизации}"
    local target_branch="${2:-$CI_DEFAULT_BRANCH}"
    local title="${3:-Автоматический merge request от CI}"
  
    # Проверка обязательных переменных CI
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
    : "${CI_COMMIT_REF_NAME:?Не задана переменная CI_COMMIT_REF_NAME}"
    : "${target_branch:?Не задана целевая ветка и CI_DEFAULT_BRANCH пуст}"
  
    CREATE_MERGE_JSON=$(jq -n \
        --arg source_branch "${CI_COMMIT_REF_NAME}" \
        --arg target_branch "${target_branch}" \
        --arg title "${title}" \
        '{source_branch: $source_branch, target_branch: $target_branch, squash: true, title: $title }'
    )
  
    # Выполним запрос на создание MR
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${CREATE_MERGE_JSON}" \
      "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
  }

  merge_merge_request() {
      token="$1"
      iid="$2"
  
      if [ -z "$token" ]; then
          log_info "Не передан токен авторизации" >&2
          return 1
      fi
      if [ -z "$iid" ]; then
          log_info "Не передан ID Merge Request" >&2
          return 1
      fi
  
      if [ -z "$CI_API_V4_URL" ]; then
          log_info "Не задана переменная CI_API_V4_URL" >&2
          return 1
      fi
      if [ -z "$CI_PROJECT_ID" ]; then
          log_info "Не задана переменная CI_PROJECT_ID" >&2
          return 1
      fi
      if [ -z "$CI_COMMIT_MESSAGE" ]; then
          log_info "Не задана переменная CI_COMMIT_MESSAGE" >&2
          return 1
      fi
  
      # Получаем информацию о текущем MR
      MR_info=$(curl -s -f -X GET \
          -H "Authorization: Bearer $token" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid") || return 1
  
      log_info "$MR_info"
  
      remove_branch="$AUTO_REMOVE_SOURCE_BRANCH"
  
      if [ "$CI_MERGE_REQUEST_SOURCE_BRANCH_PROTECTED" = "true" ]; then
          log_info "Ветка защищена, принудительно отключаем удаление после merge"
          remove_branch="false"
      fi
  
      merge_status=$(echo "$MR_info" | jq -r '.merge_status')
  
      # Определяем, нужен ли auto_merge
      auto_merge_json=""
      if [ "$merge_status" = "checking" ]; then
          auto_merge_json=", \"auto_merge\": true"
      fi
  
      MERGE_MERGE_JSON=$(jq -n \
          --arg remove_branch "$remove_branch" \
          --arg auto_merge_strategy "merge_when_pipeline_succeeds" \
          --arg squash_commit_message "$CI_COMMIT_MESSAGE" \
          '{
            should_remove_source_branch: ($remove_branch == "true"), 
            auto_merge_strategy: $auto_merge_strategy, 
            squash: true, 
            squash_commit_message: $squash_commit_message
          }')
  
      if [ -n "$auto_merge_json" ]; then
          MERGE_MERGE_JSON=$(echo "$MERGE_MERGE_JSON" | jq '. + {auto_merge: true}')
      fi
  
      # Первый merge
      if ! curl -f -X PUT \
          -H "Authorization: Bearer $token" \
          -H "Content-Type: application/json" \
          -d "$MERGE_MERGE_JSON" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"; then
  
          log_info "Первый merge не удался, пробуем повторно без auto_merge"
  
          # Убираем auto_merge
          MERGE_MERGE_JSON_NO_AUTO=$(echo "$MERGE_MERGE_JSON" | jq 'del(.auto_merge)')
  
          curl -f -X PUT \
            -H "Authorization: Bearer $token" \
            -H "Content-Type: application/json" \
            -d "$MERGE_MERGE_JSON_NO_AUTO" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"
      fi
  }

.gitlab-api-approve: |
  approve_merge_request() {
      local token="${1:?Не передан токен авторизации}"
      local iid="${2:?Не передан IID merge request}"

      # Проверка обязательных переменных CI
      : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"

      # Выполним запрос на approve MR
      curl -X POST \
        -H "Authorization: Bearer ${token}" \
        "${CI_API_V4_URL}/projects/$CI_PROJECT_ID/merge_requests/$iid/approve"
  }

.gitlab-api-tags: |
  api_get_tags() {
    local token="${1:?Не передан токен авторизации}"
    local search="${2:-}"  # Можно передавать фильтр
  
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
  
    local api_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"
  
    tag_list=$(curl -s -f -X GET \
      -H "Authorization: Bearer ${token}" \
      --data-urlencode "order_by=version" \
      --data-urlencode "sort=desc" \
      $( [ -n "$search" ] && echo "--data-urlencode search=$search" ) \
      "$api_url")
    
    echo "$tag_list"
  }
  
  get_last_release_tag() {
    local tags_json="${1:-[]}"
    echo "$tags_json" | jq -r 'if type=="array" and length>0 then .[0] else empty end'
  }
  
  get_patch_from_tag() {
    local tag="$1"
    
    # Убираем "v" в начале, если есть
    tag="${tag#v}"
    
    # Разбиваем на части
    set -- $(echo "$tag" | tr '.' ' ')
    local major="$1"
    local minor="$2"
    local patch="$3"
    
    # Проверяем, что patch — число
    case "$patch" in
      ''|*[!0-9]*) patch=0 ;;
    esac
    
    echo "$patch"
  }

  create_next_tag() {
    local token="${1:?Не передан токен авторизации}"
  
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
    : "${CI_DEFAULT_BRANCH:?Не задана переменная CI_DEFAULT_BRANCH}"
  
    # Получаем теги с нужным мажором и минором, отсортированные по версии (desc)
    TAGS_JSON=$(api_get_tags "$token" "${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}." | tr -d '\r' )
    
    printf '%s\n' "$TAGS_JSON" | jq .
    
    LAST_TAG=$(get_last_release_tag "$TAGS_JSON")

    log_info "$LAST_TAG" 
  
    if [ -z "$LAST_TAG" ]; then
      patch=0
      ref="$CI_DEFAULT_BRANCH"
    else
      patch=$(get_patch_from_tag "$(echo "$LAST_TAG" | jq -r '.name')")
      patch=$((patch + 1))
      ref=$(echo "$LAST_TAG" | jq -r '.commit.id')
    fi

    # Формируем имя нового тега
    new_tag="${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}.${patch}"
    log_info "Создаем тег: $new_tag (ref: $ref)"

    CREATE_TAG_JSON=$(jq -n \
      --arg tag_name "$new_tag" \
      --arg _ref "$ref" \
      '{ tag_name: $tag_name, ref: $_ref }'
    )

    log_info "$CREATE_TAG_JSON"
  
    # Создаем тег через API
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${CREATE_TAG_JSON}" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"  
  }
 

.gitlab-api-release: |
  create_release_with_artifacts() {
    local token="${1:?Не передан токен авторизации}"
    local ARTIFACTS_DIR="$2"

    # Данные релиза
    RELEASE_JSON=$(jq -n \
        --arg name "Release $CI_COMMIT_TAG" \
        --arg tag_name "$CI_COMMIT_TAG" \
        --arg description "Automated release for tag $CI_COMMIT_TAG" \
        '{name: $name, tag_name: $tag_name, description: $description, assets: {links: []}}'
    )

    # --- Проверяем docker.env ---
    if [ -f "docker.env" ]; then
        log_info "🐳 Found docker.env — adding docker image info to release assets"
        # Загружаем переменные из docker.env
        source docker.env
        
        # Добавляем docker_image как ссылку
        RELEASE_JSON=$(echo "$RELEASE_JSON" | jq \
            --arg name "docker_image" \
            --arg url "$docker_image" \
            --arg filepath "/docker_image" \
            '.assets.links += [{"name": $name, "url": $url, "link_type": "image", "filepath": $filepath}]'
        )
        
        # Добавляем docker_digest как ссылку
        RELEASE_JSON=$(echo "$RELEASE_JSON" | jq \
            --arg name "docker_digest" \
            --arg url "$docker_image_digest" \
            --arg filepath "/docker_digest" \
            '.assets.links += [{"name": $name, "url": $url, "link_type": "image", "filepath": $filepath}]'
        )
    else
        log_info "⚠️ docker.env not found — skipping docker info"
    fi


    # Если есть артефакты, добавляем их как links
    if [ -d "$ARTIFACTS_DIR" ] && [ "$(ls -A "$ARTIFACTS_DIR" 2>/dev/null)" ]; then
        log_info "📦 Found artifact directories — preparing assets..."

        for package_dir in "$ARTIFACTS_DIR"/*; do
            [ -d "$package_dir" ] || continue
            local PACKAGE_NAME
            PACKAGE_NAME=$(basename "$package_dir")
            log_info "📂 Processing package: $PACKAGE_NAME"

            for file in "$package_dir"/*; do
                [ -f "$file" ] || continue
                local filename
                filename=$(basename "$file")
                url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME/$VERSION/$filename"

                log_info "🔗 Adding asset link for $PACKAGE_NAME → $filename"
                RELEASE_JSON=$(echo "$RELEASE_JSON" | jq \
                    --arg name "$PACKAGE_NAME/$filename" \
                    --arg url "$url" \
                    --arg filepath "/$filename" \
                    '.assets.links += [{"name": $name, "url": $url, "link_type": "package", "filepath": $filepath}]'
                )
            done
        done
    else
        log_info "⚠️ No artifacts found — release will be created without assets."
    fi

    # URL GitLab API
    local API_URL="$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases"
  
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${RELEASE_JSON}" \
      "$API_URL"
  }




"auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
    - !reference [ .gitlab-api-rebase ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "Нет открытых merge requests для ветки ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          rebase_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [.merge-to-protected-branch, rules]
    - if: '"$[[ inputs.auto-rebase ]]" == "true"'
      when: on_success
    - when: never

"auto-approve$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  needs:
    - job: "auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
    - !reference [ .gitlab-api-approve ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "Нет открытых merge requests для ветки ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          approve_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [.merge-to-protected-branch, rules]
    - if: '"$[[ inputs.auto-approve ]]" == "true"'
      when: on_success
    - when: never

"auto-merge$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  needs:
    - job: "auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - job: "auto-approve$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "Нет открытых merge requests для ветки ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          merge_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [.merge-to-protected-branch, rules]
    - if: '"$[[ inputs.auto-merge ]]" == "true"'
      when: on_success
    - when: never

"auto-create-TAG$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  needs:
    - job: "auto-merge$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - $[[ inputs.dependencies-jobs ]]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-tags ]
  script:
    - create_next_tag "$AUTO_GITLAB_TOKEN"
  rules:
    - !reference [.protected-branch-commit, rules]
    - if: '"$[[ inputs.auto-tag ]]" == "true"'
      when: on_success
    - when: never

"auto-release$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-release
  extends: [ .package-cache ]
  needs:
    - job: "auto-create-TAG$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
  dependencies:
    - $[[ inputs.dependencies-jobs ]]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-release ]
  script:
    - create_release_with_artifacts "$AUTO_GITLAB_TOKEN"
  rules:
    - !reference [.tags-only-pattern, rules]
    - if: '"$[[ inputs.auto-release ]]" == "true"'
      when: on_success
    - when: never












#.gitlab_api_rebase: |
#  # BEGSCRIPT
#
#  set -e
#
#  function get_opened_merge_requests() {
#    local branch="${1:-$CI_COMMIT_REF_NAME}"
#    local target_branch="${2:-}"
#
#    log_info "Getting opened MRs for source branch: $branch"
#
#    local api_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened&source_branch=$branch"
#
#    if [ -n "$target_branch" ]; then
#      api_url="$api_url&target_branch=$target_branch"
#    fi
#
#    curl -s -k -f -H "Authorization: Bearer $AUTO_MERGE_GITHUB" "$api_url"
#  }
#
#  function wait_for_rebase() {
#    local iid=$1
#
#    # Запуск rebase
#    log_info "Starting rebase for MR !$iid..."
#    curl -k -X PUT -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#      -d "skip_ci=true" \
#      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/rebase" > /dev/null 2>&1
#
#    # Ожидание завершения
#    for i in {1..30}; do
#      data=$(curl -s -k -H "Authorization: Bearer $token" \
#        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid")
#
#      rebase_status=$(echo "$data" | jq -r '.rebase_in_progress')
#
#      if [ "$rebase_status" = "false" ]; then
#        merge_status=$(echo "$data" | jq -r '.merge_status')
#        if [ "$merge_status" = "can_be_merged" ]; then
#          echo "✅ Rebase completed successfully"
#          return 0
#        else
#          echo "❌ Rebase done but cannot merge: $merge_status"
#          return 1
#        fi
#      fi
#      sleep 10
#    done
#    echo "❌ Rebase timeout"
#    return 1
#  }
#
#
#.is_merge_request_rule:
#  - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_PROTECTED != "true"'
#    when: never
#  - if: '$CI_PIPELINE_SOURCE != "merge_request_event"'
#    when: never
#
#
#test$[[ inputs.job-prefix | expand_vars | expand_vars ]]:
#  stage: package
#  needs:
#    - $[[ inputs.dependencies-jobs ]]
#  dependencies:
#    - $[[ inputs.dependencies-jobs ]]
#  script:
#    - echo "123"
#    - ls -all ./
#  rules:
#    - !reference [ .is_merge_request_rule ]
#    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ "^[0-9]+\\.[0-9]+\\.[0-9]+$"'
#      variables:
#        VERSION: "$CI_COMMIT_TAG"
#    - when: always
#
#"push-to-package-registry$[[ inputs.job-prefix | expand_vars ]]":
#  stage: package
#  dependencies:
#    - $[[ inputs.dependencies-jobs ]]
#  variables:
#    VERSION: "snapshot-$CI_PIPELINE_ID"
#  before_script:
#    - !reference [ .logs-scripts ]
#  script:
#    - cd "$CI_PROJECT_DIR"
#    - ARTIFACTS_DIR="artifacts-$CI_PROJECT_ID-$CI_JOB_ID"
#    - log_info "Uploading all files from ./artifacts to GitLab Package Registry..."
#    - |
#      if [ ! -d "$ARTIFACTS_DIR" ] || [ -z "$(ls -A "$ARTIFACTS_DIR" 2>/dev/null)" ]; then
#        log_warn "⚠️ No artifacts found in $ARTIFACTS_DIR — nothing to upload."
#        exit 0
#      fi
#    - |
#      for package_dir in "$ARTIFACTS_DIR"/*; do
#        [ -d "$package_dir" ] || continue
#        PACKAGE_NAME=$(basename "$package_dir")
#        log_info "📦 Processing package: $PACKAGE_NAME"
#
#        # Проходим по всем файлам внутри
#        for file in "$package_dir"/*; do
#          [ -f "$file" ] || continue
#          file_name=$(basename "$file")
#          log_info "⬆️ Uploading $file_name to package $PACKAGE_NAME ($VERSION)..."
#
#          curl -s -k -f --header "JOB-TOKEN: $CI_JOB_TOKEN" \
#            --upload-file "$file" \
#            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME/$VERSION/$file_name"
#
#          if [ $? -eq 0 ]; then
#            log_info "✅ Uploaded: $file_name"
#          else
#            log_error "❌ Failed to upload: $file_name"
#          fi
#        done
#      done
#  rules:
#    - !reference [ .is_merge_request_rule ]
#    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ "^[0-9]+\\.[0-9]+\\.[0-9]+$"'
#      variables:
#        VERSION: "$CI_COMMIT_TAG"
#    - when: never
#
#
#auto-merge$[[ inputs.job-prefix | expand_vars ]]:
#  stage: merge
#  before_script:
#    - !reference [ .logs-scripts ]
#    - !reference [ .logs-gitlab_api_rebase ]
#    - !reference [ .logs-gitlab_api_rebase ]
#  script:
#    - |
#      opened_merge_requests=$(curl -s -k -f -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened" | \
#            jq --arg branch "$CI_COMMIT_REF_NAME" '[.[] | select(.source_branch == $branch)]')
#    - |
#      for iid in $(echo "$opened_merge_requests" | jq '.[] | .iid'); do
#        # 1️⃣ Ребейзим MR
#        curl -k -X PUT -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#          -d skip_ci=true \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/rebase"
#
#        # 2️⃣ Автоматически одобряем MR
#        curl -k -X POST -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/approve"
#
#        # 3️⃣ Выполняем merge
#        curl -k -f -X PUT -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#          -d merge_when_pipeline_succeeds=true \
#          -d squash=true \
#          -d squash_commit_message="$CI_COMMIT_MESSAGE" \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"
#
#
#      done
#  rules:
#    - !reference [.is_merge_request_rule]
#    - if: '"$[[ inputs.auto-merge ]]" == "true"'
#      when: on_success
#    - when: never
##
##auto-remove-source-branch-$[[ inputs.job-prefix | expand_vars ]]:
##  stage: merge
##  needs:
##    - auto-merge-$[[ inputs.job-prefix | expand_vars ]]
##  before_script:
##    - !reference [ .logs-scripts ]
##  script:
##    - |
##      # 1️⃣ Удаляем исходную ветку
##      curl -k -f -X DELETE -H "Authorization: Bearer $PROJECT_TOKEN" \
##        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/branches/$CI_COMMIT_REF_NAME"
##      log_info "Удалена ветка: $CI_COMMIT_REF_NAME"
##  rules:
##    - !reference [.is_merge_request_rule]
##    - if: '"$[[ inputs.auto-remove-source-branch ]]" == "true"'
##      when: always
##    - when: never
#
#auto-release$[[ inputs.job-prefix | expand_vars ]]:
#  stage: release
#  needs:
#    - auto-merge$[[ inputs.job-prefix | expand_vars ]]
#    - "$[[ inputs.dependencies-jobs ]]"
#  dependencies: ["$[[ inputs.dependencies-jobs ]]"]
#  variables:
#    VERSION: "$CI_COMMIT_TAG"
#  before_script:
#    - !reference [ .logs-scripts ]
#  script:
#    - |
#      # 1️⃣ Переходим в папку с артефактами
#      ARTIFACTS_DIR="artifacts-$CI_PROJECT_ID-$CI_JOB_ID"
#
#      # 2️⃣ Формируем массив параметров для curl
#      curl_params=(
#        -k -f --request POST --header "PRIVATE-TOKEN: $CI_JOB_TOKEN"
#        --form "name=Release $CI_COMMIT_TAG"
#        --form "tag_name=$CI_COMMIT_TAG"
#        --form "description=Automated release for tag $CI_COMMIT_TAG"
#      )
#
#      # 3️⃣ Проверяем, что директория существует и не пуста
#      if [ -d "$ARTIFACTS_DIR" ] && [ "$(ls -A "$ARTIFACTS_DIR" 2>/dev/null)" ]; then
#        log_info "📦 Found artifact directories — preparing assets..."
#
#        # Обходим все поддиректории (каждая = PACKAGE_NAME)
#        for package_dir in "$ARTIFACTS_DIR"/*; do
#          [ -d "$package_dir" ] || continue
#          PACKAGE_NAME=$(basename "$package_dir")
#          log_info "📂 Processing package: $PACKAGE_NAME"
#
#          # Проходим по всем файлам внутри директории пакета
#          for file in "$package_dir"/*; do
#            [ -f "$file" ] || continue
#            filename=$(basename "$file")
#
#            log_info "🔗 Adding asset link for $PACKAGE_NAME → $filename"
#            curl_params+=(--form "assets[links][][name]=$PACKAGE_NAME/$filename")
#            curl_params+=(--form "assets[links][][url]=$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME/$VERSION/$filename")
#          done
#        done
#      else
#        log_warn "⚠️ No artifacts found — release will be created without assets."
#      fi
#
#      # 4️⃣ URL релиза
#      curl_params+=("$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases")
#
#      # 5️⃣ Выполняем POST-запрос
#      curl "${curl_params[@]}"
#  rules:
#    - !reference [.is_merge_request_rule]
#    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ "^[0-9]+\\.[0-9]+\\.[0-9]+$" && "$[[ inputs.auto-release ]]" == "true"'
#      when: on_success
#    - when: never



#        # 4️⃣ Проверяем, что merge завершён
#        max_retries=30
#        sleep_seconds=10
#        for i in $(seq 1 $max_retries); do
#        merge_status=$(curl -s -k -f -H "Authorization: Bearer $PROJECT_TOKEN" \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid" | jq -r '.merge_status')
#        
#        if [ "$merge_status" = "merged" ]; then
#        log_info "MR $iid успешно слит"
#        break
#        else
#        log_info "MR $iid ещё не слит, пробуем снова через $sleep_seconds секунд ($i/$max_retries)"
#        sleep $sleep_seconds
#        fi
#        
#        # Если достигли последней попытки
#        if [ "$i" -eq "$max_retries" ]; then
#        log_info "MR $iid не был слит за отведённое время"
#        exit 1
#        fi
#        done