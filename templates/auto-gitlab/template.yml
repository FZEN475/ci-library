# templates/auto-gitlab/template.yml
spec:
  inputs:
    job-prefix:
      description: "Job prefix"
      type: string
      default: "-$CI_PROJECT_ID-$CI_COMMIT_SHORT_SHA"
      
    auto-rebase:
      description: "Auto rebase source branch"
      type: boolean
      default: false
      
    auto-approve:
      description: "Auto approve merge request"
      type: boolean
      default: false
    
    auto-merge:
      description: "Auto confirm merge request"
      type: boolean
      default: false
    auto-remove-source-branch:
      description: "Auto remove source branch after merge"
      type: boolean
      default: false
      
    auto-tag:
      description: "Create auto TAG."
      type: boolean
      default: false
    auto-tag-pattern:
      description: "Validate TAG by pattern" # "/^[vV]?\\d\\.\\d+\\.\\d+$/" –∏–ª–∏ /^[vV]?\d\.\d+\.\d+$/
      type: string
      default: /^[vV]?\d\.\d+\.\d+$/
    auto-tag-version-prefix:
      description: "Prefix for autogenerated tag"
      type: string
      default: ""
    auto-tag-version-major:
      type: string
      default: "0"
    auto-tag-version-minor:
      type: string
      default: "0"      
      
    auto-release:
      description: "Auto release after merge"
      type: boolean
      default: false
    dependencies-jobs:
      description: "Artifact job list"
      type: array
      default: []
    
---

include:
  - local: 'templates/-1-common-rules/template.yml'

variables: 
  AUTO_REMOVE_SOURCE_BRANCH: $[[ inputs.auto-remove-source-branch ]]
  CI_COMMIT_TAG_PATTERN: $[[ inputs.auto-tag-pattern ]]
  AUTO_TAG_VERSION_PREFIX: $[[ inputs.auto-tag-version-prefix ]]
  AUTO_TAG_VERSION_MAJOR: $[[ inputs.auto-tag-version-major ]]
  AUTO_TAG_VERSION_MINOR: $[[ inputs.auto-tag-version-minor ]]

stages:
  - auto-merge
  - auto-release
    

.gitlab-api-rebase: |
  rebase_merge_request() {
      local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"
      local iid="${2:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω IID merge request}"
      local timeout="${3:-60}"   # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
      local interval=5            # –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏

      # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö CI
      : "${CI_API_V4_URL:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID}"

      REBASE_JSON=$(jq -n \
          '{
            "skip_ci": true
          }'
      )

      local api_url="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${iid}/rebase"

      # –ó–∞–ø—É—Å–∫–∞–µ–º rebase
      log_info "–ó–∞–ø—É—Å–∫ rebase –¥–ª—è MR IID=${iid}..."
      rebase_info=$(curl -f -X PUT \
          -H "Authorization: Bearer ${token}" \
          -H "Content-Type: application/json" \
          -d "${REBASE_JSON}" \
          "${api_url}" || fail "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å rebase –¥–ª—è MR IID=${iid}")

      log_info "$rebase_info"
  
      log_info "Rebase –∑–∞–ø—É—â–µ–Ω, –æ–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è..."

      local elapsed=0
      while [ "$elapsed" -lt "$timeout" ]; do
          local local_result
          local in_progress
          local merge_error

          local_result=$(curl -s -X GET \
            -H "Authorization: Bearer ${token}" \
            --data-urlencode "include_rebase_in_progress=true" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${iid}")

          log_info "$local_result"

          in_progress=$(echo "$local_result" | jq -r '.rebase_in_progress')
          merge_error=$(echo "$local_result" | jq -r '.merge_error')

          if [[ "$in_progress" == "false" ]]; then
              if [[ "$merge_error" != "null" ]]; then
                  fail "Rebase –¥–ª—è MR IID=${iid} –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π: $merge_error"
              else
                  log_info "Rebase –¥–ª—è MR IID=${iid} –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ."
                  return 0
              fi
          fi

          sleep $interval
          elapsed=$((elapsed + interval))
      done

      fail "Rebase –¥–ª—è MR IID=${iid} –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –∑–∞ ${timeout} —Å–µ–∫—É–Ω–¥."
  }
  
.gitlab-api-merge: |
  get_open_merge_requests() {
      local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"

      : "${CI_API_V4_URL:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID}"
      : "${CI_COMMIT_REF_NAME:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_COMMIT_REF_NAME}"

      mr_list=$(curl -s -f -X GET \
        -H "Authorization: Bearer ${token}" \
        --data-urlencode "state=opened" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests")
  
      filtered_mr=$(echo "$mr_list" | jq --arg branch "$CI_COMMIT_REF_NAME" '[.[] | select(.source_branch==$branch)]')

      if [ -n "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" ]; then
        filtered_mr=$(echo "$filtered_mr" | jq --arg target "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" '[.[] | select(.target_branch==$target)]')
      fi

      echo "$filtered_mr"
  }

  create_merge_request() {
    local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"
    local target_branch="${2:-$CI_DEFAULT_BRANCH}"
    local title="${3:-–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π merge request –æ—Ç CI}"
  
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö CI
    : "${CI_API_V4_URL:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID}"
    : "${CI_COMMIT_REF_NAME:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_COMMIT_REF_NAME}"
    : "${target_branch:?–ù–µ –∑–∞–¥–∞–Ω–∞ —Ü–µ–ª–µ–≤–∞—è –≤–µ—Ç–∫–∞ –∏ CI_DEFAULT_BRANCH –ø—É—Å—Ç}"
  
    CREATE_MERGE_JSON=$(jq -n \
        --arg source_branch "${CI_COMMIT_REF_NAME}" \
        --arg target_branch "${target_branch}" \
        --arg title "${title}" \
        '{source_branch: $source_branch, target_branch: $target_branch, squash: true, title: $title }'
    )
  
    # –í—ã–ø–æ–ª–Ω–∏–º –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ MR
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${CREATE_MERGE_JSON}" \
      "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
  }

  merge_merge_request() {
      token="$1"
      iid="$2"
  
      if [ -z "$token" ]; then
          log_info "–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏" >&2
          return 1
      fi
      if [ -z "$iid" ]; then
          log_info "–ù–µ –ø–µ—Ä–µ–¥–∞–Ω ID Merge Request" >&2
          return 1
      fi
  
      if [ -z "$CI_API_V4_URL" ]; then
          log_info "–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL" >&2
          return 1
      fi
      if [ -z "$CI_PROJECT_ID" ]; then
          log_info "–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID" >&2
          return 1
      fi
      if [ -z "$CI_COMMIT_MESSAGE" ]; then
          log_info "–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_COMMIT_MESSAGE" >&2
          return 1
      fi
  
      # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º MR
      MR_info=$(curl -s -f -X GET \
          -H "Authorization: Bearer $token" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid") || return 1
  
      log_info "$MR_info"
  
      remove_branch="$AUTO_REMOVE_SOURCE_BRANCH"
  
      if [ "$CI_MERGE_REQUEST_SOURCE_BRANCH_PROTECTED" = "true" ]; then
          log_info "–í–µ—Ç–∫–∞ –∑–∞—â–∏—â–µ–Ω–∞, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ merge"
          remove_branch="false"
      fi
  
      merge_status=$(echo "$MR_info" | jq -r '.merge_status')
  
      # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ auto_merge
      auto_merge_json=""
      if [ "$merge_status" = "checking" ]; then
          auto_merge_json=", \"auto_merge\": true"
      fi
  
      MERGE_MERGE_JSON=$(jq -n \
          --arg remove_branch "$remove_branch" \
          --arg auto_merge_strategy "merge_when_pipeline_succeeds" \
          --arg squash_commit_message "$CI_COMMIT_MESSAGE" \
          '{
            should_remove_source_branch: ($remove_branch == "true"), 
            auto_merge_strategy: $auto_merge_strategy, 
            squash: true, 
            squash_commit_message: $squash_commit_message
          }')
  
      if [ -n "$auto_merge_json" ]; then
          MERGE_MERGE_JSON=$(echo "$MERGE_MERGE_JSON" | jq '. + {auto_merge: true}')
      fi
  
      # –ü–µ—Ä–≤—ã–π merge
      if ! curl -f -X PUT \
          -H "Authorization: Bearer $token" \
          -H "Content-Type: application/json" \
          -d "$MERGE_MERGE_JSON" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"; then
  
          log_info "–ü–µ—Ä–≤—ã–π merge –Ω–µ —É–¥–∞–ª—Å—è, –ø—Ä–æ–±—É–µ–º –ø–æ–≤—Ç–æ—Ä–Ω–æ –±–µ–∑ auto_merge"
  
          # –£–±–∏—Ä–∞–µ–º auto_merge
          MERGE_MERGE_JSON_NO_AUTO=$(echo "$MERGE_MERGE_JSON" | jq 'del(.auto_merge)')
  
          curl -f -X PUT \
            -H "Authorization: Bearer $token" \
            -H "Content-Type: application/json" \
            -d "$MERGE_MERGE_JSON_NO_AUTO" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"
      fi
  }

.gitlab-api-approve: |
  approve_merge_request() {
      local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"
      local iid="${2:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω IID merge request}"

      # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö CI
      : "${CI_API_V4_URL:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL}"
      : "${CI_PROJECT_ID:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID}"

      # –í—ã–ø–æ–ª–Ω–∏–º –∑–∞–ø—Ä–æ—Å –Ω–∞ approve MR
      curl -X POST \
        -H "Authorization: Bearer ${token}" \
        "${CI_API_V4_URL}/projects/$CI_PROJECT_ID/merge_requests/$iid/approve"
  }

.gitlab-api-tags: |
  api_get_tags() {
    local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"
    local search="${2:-}"  # –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä
  
    : "${CI_API_V4_URL:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID}"
  
    local api_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"
  
    tag_list=$(curl -s -f -X GET \
      -H "Authorization: Bearer ${token}" \
      --data-urlencode "order_by=version" \
      --data-urlencode "sort=desc" \
      $( [ -n "$search" ] && echo "--data-urlencode search=$search" ) \
      "$api_url")
    
    echo "$tag_list"
  }
  
  get_last_release_tag() {
    local tags_json="${1:-[]}"
    echo "$tags_json" | jq -r 'if type=="array" and length>0 then .[0] else empty end'
  }
  
  get_patch_from_tag() {
    local tag="$1"
    
    # –£–±–∏—Ä–∞–µ–º "v" –≤ –Ω–∞—á–∞–ª–µ, –µ—Å–ª–∏ –µ—Å—Ç—å
    tag="${tag#v}"
    
    # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏
    set -- $(echo "$tag" | tr '.' ' ')
    local major="$1"
    local minor="$2"
    local patch="$3"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ patch ‚Äî —á–∏—Å–ª–æ
    case "$patch" in
      ''|*[!0-9]*) patch=0 ;;
    esac
    
    echo "$patch"
  }

  create_next_tag() {
    local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"
  
    : "${CI_API_V4_URL:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_PROJECT_ID}"
    : "${CI_DEFAULT_BRANCH:?–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è CI_DEFAULT_BRANCH}"
  
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–≥–∏ —Å –Ω—É–∂–Ω—ã–º –º–∞–∂–æ—Ä–æ–º –∏ –º–∏–Ω–æ—Ä–æ–º, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ –≤–µ—Ä—Å–∏–∏ (desc)
    TAGS_JSON=$(api_get_tags "$token" "${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}." | tr -d '\r' )
    
    printf '%s\n' "$TAGS_JSON" | jq .
    
    LAST_TAG=$(get_last_release_tag "$TAGS_JSON")

    log_info "$LAST_TAG" 
  
    if [ -z "$LAST_TAG" ]; then
      patch=0
      ref="$CI_DEFAULT_BRANCH"
    else
      patch=$(get_patch_from_tag "$(echo "$LAST_TAG" | jq -r '.name')")
      patch=$((patch + 1))
      ref=$(echo "$LAST_TAG" | jq -r '.commit.id')
    fi

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è –Ω–æ–≤–æ–≥–æ —Ç–µ–≥–∞
    new_tag="${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}.${patch}"
    log_info "–°–æ–∑–¥–∞–µ–º —Ç–µ–≥: $new_tag (ref: $ref)"

    CREATE_TAG_JSON=$(jq -n \
      --arg tag_name "$new_tag" \
      --arg _ref "$ref" \
      '{ tag_name: $tag_name, ref: $_ref }'
    )

    log_info "$CREATE_TAG_JSON"
  
    # –°–æ–∑–¥–∞–µ–º —Ç–µ–≥ —á–µ—Ä–µ–∑ API
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${CREATE_TAG_JSON}" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"  
  }
 

.gitlab-api-release: |
  create_release_with_artifacts() {
    local token="${1:?–ù–µ –ø–µ—Ä–µ–¥–∞–Ω —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏}"
    local ARTIFACTS_DIR="$2"

    # –î–∞–Ω–Ω—ã–µ —Ä–µ–ª–∏–∑–∞
    RELEASE_JSON=$(jq -n \
        --arg name "Release $CI_COMMIT_TAG" \
        --arg tag_name "$CI_COMMIT_TAG" \
        --arg description "Automated release for tag $CI_COMMIT_TAG" \
        '{name: $name, tag_name: $tag_name, description: $description, assets: {links: []}}'
    )

    # --- –ü—Ä–æ–≤–µ—Ä—è–µ–º docker.env ---
    if [ -f "docker.env" ]; then
        log_info "üê≥ Found docker.env ‚Äî adding docker image info to release assets"
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ docker.env
        source docker.env
        
        # –î–æ–±–∞–≤–ª—è–µ–º docker_image –∫–∞–∫ —Å—Å—ã–ª–∫—É
        RELEASE_JSON=$(echo "$RELEASE_JSON" | jq \
            --arg name "docker_image" \
            --arg url "$docker_image" \
            --arg filepath "/docker_image" \
            '.assets.links += [{"name": $name, "url": $url, "link_type": "image", "filepath": $filepath}]'
        )
        
        # –î–æ–±–∞–≤–ª—è–µ–º docker_digest –∫–∞–∫ —Å—Å—ã–ª–∫—É
        RELEASE_JSON=$(echo "$RELEASE_JSON" | jq \
            --arg name "docker_digest" \
            --arg url "$docker_image_digest" \
            --arg filepath "/docker_digest" \
            '.assets.links += [{"name": $name, "url": $url, "link_type": "image", "filepath": $filepath}]'
        )
    else
        log_info "‚ö†Ô∏è docker.env not found ‚Äî skipping docker info"
    fi


    # –ï—Å–ª–∏ –µ—Å—Ç—å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã, –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö –∫–∞–∫ links
    if [ -d "$ARTIFACTS_DIR" ] && [ "$(ls -A "$ARTIFACTS_DIR" 2>/dev/null)" ]; then
        log_info "üì¶ Found artifact directories ‚Äî preparing assets..."

        for package_dir in "$ARTIFACTS_DIR"/*; do
            [ -d "$package_dir" ] || continue
            local PACKAGE_NAME
            PACKAGE_NAME=$(basename "$package_dir")
            log_info "üìÇ Processing package: $PACKAGE_NAME"

            for file in "$package_dir"/*; do
                [ -f "$file" ] || continue
                local filename
                filename=$(basename "$file")
                url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME/$VERSION/$filename"

                log_info "üîó Adding asset link for $PACKAGE_NAME ‚Üí $filename"
                RELEASE_JSON=$(echo "$RELEASE_JSON" | jq \
                    --arg name "$PACKAGE_NAME/$filename" \
                    --arg url "$url" \
                    --arg filepath "/$filename" \
                    '.assets.links += [{"name": $name, "url": $url, "link_type": "package", "filepath": $filepath}]'
                )
            done
        done
    else
        log_info "‚ö†Ô∏è No artifacts found ‚Äî release will be created without assets."
    fi

    # URL GitLab API
    local API_URL="$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases"
  
    curl -f -X POST \
      -H "Authorization: Bearer ${token}" \
      -H "Content-Type: application/json" \
      -d "${RELEASE_JSON}" \
      "$API_URL"
  }




"auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
    - !reference [ .gitlab-api-rebase ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "–ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö merge requests –¥–ª—è –≤–µ—Ç–∫–∏ ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          rebase_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [.merge-to-protected-branch, rules]
    - if: '"$[[ inputs.auto-rebase ]]" == "true"'
      when: on_success
    - when: never

"auto-approve$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  needs:
    - job: "auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
    - !reference [ .gitlab-api-approve ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "–ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö merge requests –¥–ª—è –≤–µ—Ç–∫–∏ ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          approve_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [.merge-to-protected-branch, rules]
    - if: '"$[[ inputs.auto-approve ]]" == "true"'
      when: on_success
    - when: never

"auto-merge$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  needs:
    - job: "auto-rebase-source-branch$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - job: "auto-approve$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-merge ]
  script:
    - |
      mr_iids=$(get_open_merge_requests "$CI_JOB_TOKEN" | jq -r '.[].iid')
      if [[ -z "$mr_iids" ]]; then
          log_info "–ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö merge requests –¥–ª—è –≤–µ—Ç–∫–∏ ${CI_COMMIT_REF_NAME}."
          exit 0
      fi
      for iid in $mr_iids; do
          merge_merge_request "$AUTO_GITLAB_TOKEN" "$iid"
      done
  rules:
    - !reference [.merge-to-protected-branch, rules]
    - if: '"$[[ inputs.auto-merge ]]" == "true"'
      when: on_success
    - when: never

"auto-create-TAG$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-merge
  extends: [ .package-cache ]
  needs:
    - job: "auto-merge$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
    - $[[ inputs.dependencies-jobs ]]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-tags ]
  script:
    - create_next_tag "$AUTO_GITLAB_TOKEN"
  rules:
    - !reference [.protected-branch-commit, rules]
    - if: '"$[[ inputs.auto-tag ]]" == "true"'
      when: on_success
    - when: never

"auto-release$[[ inputs.job-prefix | expand_vars ]]":
  stage: auto-release
  extends: [ .package-cache ]
  needs:
    - job: "auto-create-TAG$[[ inputs.job-prefix | expand_vars ]]"
      optional: true
  dependencies:
    - $[[ inputs.dependencies-jobs ]]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-release ]
  script:
    - create_release_with_artifacts "$AUTO_GITLAB_TOKEN"
  rules:
    - !reference [.tags-only-pattern, rules]
    - if: '"$[[ inputs.auto-release ]]" == "true"'
      when: on_success
    - when: never












#.gitlab_api_rebase: |
#  # BEGSCRIPT
#
#  set -e
#
#  function get_opened_merge_requests() {
#    local branch="${1:-$CI_COMMIT_REF_NAME}"
#    local target_branch="${2:-}"
#
#    log_info "Getting opened MRs for source branch: $branch"
#
#    local api_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened&source_branch=$branch"
#
#    if [ -n "$target_branch" ]; then
#      api_url="$api_url&target_branch=$target_branch"
#    fi
#
#    curl -s -k -f -H "Authorization: Bearer $AUTO_MERGE_GITHUB" "$api_url"
#  }
#
#  function wait_for_rebase() {
#    local iid=$1
#
#    # –ó–∞–ø—É—Å–∫ rebase
#    log_info "Starting rebase for MR !$iid..."
#    curl -k -X PUT -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#      -d "skip_ci=true" \
#      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/rebase" > /dev/null 2>&1
#
#    # –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
#    for i in {1..30}; do
#      data=$(curl -s -k -H "Authorization: Bearer $token" \
#        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid")
#
#      rebase_status=$(echo "$data" | jq -r '.rebase_in_progress')
#
#      if [ "$rebase_status" = "false" ]; then
#        merge_status=$(echo "$data" | jq -r '.merge_status')
#        if [ "$merge_status" = "can_be_merged" ]; then
#          echo "‚úÖ Rebase completed successfully"
#          return 0
#        else
#          echo "‚ùå Rebase done but cannot merge: $merge_status"
#          return 1
#        fi
#      fi
#      sleep 10
#    done
#    echo "‚ùå Rebase timeout"
#    return 1
#  }
#
#
#.is_merge_request_rule:
#  - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_PROTECTED != "true"'
#    when: never
#  - if: '$CI_PIPELINE_SOURCE != "merge_request_event"'
#    when: never
#
#
#test$[[ inputs.job-prefix | expand_vars | expand_vars ]]:
#  stage: package
#  needs:
#    - $[[ inputs.dependencies-jobs ]]
#  dependencies:
#    - $[[ inputs.dependencies-jobs ]]
#  script:
#    - echo "123"
#    - ls -all ./
#  rules:
#    - !reference [ .is_merge_request_rule ]
#    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ "^[0-9]+\\.[0-9]+\\.[0-9]+$"'
#      variables:
#        VERSION: "$CI_COMMIT_TAG"
#    - when: always
#
#"push-to-package-registry$[[ inputs.job-prefix | expand_vars ]]":
#  stage: package
#  dependencies:
#    - $[[ inputs.dependencies-jobs ]]
#  variables:
#    VERSION: "snapshot-$CI_PIPELINE_ID"
#  before_script:
#    - !reference [ .logs-scripts ]
#  script:
#    - cd "$CI_PROJECT_DIR"
#    - ARTIFACTS_DIR="artifacts-$CI_PROJECT_ID-$CI_JOB_ID"
#    - log_info "Uploading all files from ./artifacts to GitLab Package Registry..."
#    - |
#      if [ ! -d "$ARTIFACTS_DIR" ] || [ -z "$(ls -A "$ARTIFACTS_DIR" 2>/dev/null)" ]; then
#        log_warn "‚ö†Ô∏è No artifacts found in $ARTIFACTS_DIR ‚Äî nothing to upload."
#        exit 0
#      fi
#    - |
#      for package_dir in "$ARTIFACTS_DIR"/*; do
#        [ -d "$package_dir" ] || continue
#        PACKAGE_NAME=$(basename "$package_dir")
#        log_info "üì¶ Processing package: $PACKAGE_NAME"
#
#        # –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Ñ–∞–π–ª–∞–º –≤–Ω—É—Ç—Ä–∏
#        for file in "$package_dir"/*; do
#          [ -f "$file" ] || continue
#          file_name=$(basename "$file")
#          log_info "‚¨ÜÔ∏è Uploading $file_name to package $PACKAGE_NAME ($VERSION)..."
#
#          curl -s -k -f --header "JOB-TOKEN: $CI_JOB_TOKEN" \
#            --upload-file "$file" \
#            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME/$VERSION/$file_name"
#
#          if [ $? -eq 0 ]; then
#            log_info "‚úÖ Uploaded: $file_name"
#          else
#            log_error "‚ùå Failed to upload: $file_name"
#          fi
#        done
#      done
#  rules:
#    - !reference [ .is_merge_request_rule ]
#    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ "^[0-9]+\\.[0-9]+\\.[0-9]+$"'
#      variables:
#        VERSION: "$CI_COMMIT_TAG"
#    - when: never
#
#
#auto-merge$[[ inputs.job-prefix | expand_vars ]]:
#  stage: merge
#  before_script:
#    - !reference [ .logs-scripts ]
#    - !reference [ .logs-gitlab_api_rebase ]
#    - !reference [ .logs-gitlab_api_rebase ]
#  script:
#    - |
#      opened_merge_requests=$(curl -s -k -f -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened" | \
#            jq --arg branch "$CI_COMMIT_REF_NAME" '[.[] | select(.source_branch == $branch)]')
#    - |
#      for iid in $(echo "$opened_merge_requests" | jq '.[] | .iid'); do
#        # 1Ô∏è‚É£ –†–µ–±–µ–π–∑–∏–º MR
#        curl -k -X PUT -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#          -d skip_ci=true \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/rebase"
#
#        # 2Ô∏è‚É£ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–¥–æ–±—Ä—è–µ–º MR
#        curl -k -X POST -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/approve"
#
#        # 3Ô∏è‚É£ –í—ã–ø–æ–ª–Ω—è–µ–º merge
#        curl -k -f -X PUT -H "Authorization: Bearer $AUTO_MERGE_GITHUB" \
#          -d merge_when_pipeline_succeeds=true \
#          -d squash=true \
#          -d squash_commit_message="$CI_COMMIT_MESSAGE" \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid/merge"
#
#
#      done
#  rules:
#    - !reference [.is_merge_request_rule]
#    - if: '"$[[ inputs.auto-merge ]]" == "true"'
#      when: on_success
#    - when: never
##
##auto-remove-source-branch-$[[ inputs.job-prefix | expand_vars ]]:
##  stage: merge
##  needs:
##    - auto-merge-$[[ inputs.job-prefix | expand_vars ]]
##  before_script:
##    - !reference [ .logs-scripts ]
##  script:
##    - |
##      # 1Ô∏è‚É£ –£–¥–∞–ª—è–µ–º –∏—Å—Ö–æ–¥–Ω—É—é –≤–µ—Ç–∫—É
##      curl -k -f -X DELETE -H "Authorization: Bearer $PROJECT_TOKEN" \
##        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/branches/$CI_COMMIT_REF_NAME"
##      log_info "–£–¥–∞–ª–µ–Ω–∞ –≤–µ—Ç–∫–∞: $CI_COMMIT_REF_NAME"
##  rules:
##    - !reference [.is_merge_request_rule]
##    - if: '"$[[ inputs.auto-remove-source-branch ]]" == "true"'
##      when: always
##    - when: never
#
#auto-release$[[ inputs.job-prefix | expand_vars ]]:
#  stage: release
#  needs:
#    - auto-merge$[[ inputs.job-prefix | expand_vars ]]
#    - "$[[ inputs.dependencies-jobs ]]"
#  dependencies: ["$[[ inputs.dependencies-jobs ]]"]
#  variables:
#    VERSION: "$CI_COMMIT_TAG"
#  before_script:
#    - !reference [ .logs-scripts ]
#  script:
#    - |
#      # 1Ô∏è‚É£ –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –ø–∞–ø–∫—É —Å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∞–º–∏
#      ARTIFACTS_DIR="artifacts-$CI_PROJECT_ID-$CI_JOB_ID"
#
#      # 2Ô∏è‚É£ –§–æ—Ä–º–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è curl
#      curl_params=(
#        -k -f --request POST --header "PRIVATE-TOKEN: $CI_JOB_TOKEN"
#        --form "name=Release $CI_COMMIT_TAG"
#        --form "tag_name=$CI_COMMIT_TAG"
#        --form "description=Automated release for tag $CI_COMMIT_TAG"
#      )
#
#      # 3Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ –ø—É—Å—Ç–∞
#      if [ -d "$ARTIFACTS_DIR" ] && [ "$(ls -A "$ARTIFACTS_DIR" 2>/dev/null)" ]; then
#        log_info "üì¶ Found artifact directories ‚Äî preparing assets..."
#
#        # –û–±—Ö–æ–¥–∏–º –≤—Å–µ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ (–∫–∞–∂–¥–∞—è = PACKAGE_NAME)
#        for package_dir in "$ARTIFACTS_DIR"/*; do
#          [ -d "$package_dir" ] || continue
#          PACKAGE_NAME=$(basename "$package_dir")
#          log_info "üìÇ Processing package: $PACKAGE_NAME"
#
#          # –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Ñ–∞–π–ª–∞–º –≤–Ω—É—Ç—Ä–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø–∞–∫–µ—Ç–∞
#          for file in "$package_dir"/*; do
#            [ -f "$file" ] || continue
#            filename=$(basename "$file")
#
#            log_info "üîó Adding asset link for $PACKAGE_NAME ‚Üí $filename"
#            curl_params+=(--form "assets[links][][name]=$PACKAGE_NAME/$filename")
#            curl_params+=(--form "assets[links][][url]=$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME/$VERSION/$filename")
#          done
#        done
#      else
#        log_warn "‚ö†Ô∏è No artifacts found ‚Äî release will be created without assets."
#      fi
#
#      # 4Ô∏è‚É£ URL —Ä–µ–ª–∏–∑–∞
#      curl_params+=("$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases")
#
#      # 5Ô∏è‚É£ –í—ã–ø–æ–ª–Ω—è–µ–º POST-–∑–∞–ø—Ä–æ—Å
#      curl "${curl_params[@]}"
#  rules:
#    - !reference [.is_merge_request_rule]
#    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ "^[0-9]+\\.[0-9]+\\.[0-9]+$" && "$[[ inputs.auto-release ]]" == "true"'
#      when: on_success
#    - when: never



#        # 4Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ merge –∑–∞–≤–µ—Ä—à—ë–Ω
#        max_retries=30
#        sleep_seconds=10
#        for i in $(seq 1 $max_retries); do
#        merge_status=$(curl -s -k -f -H "Authorization: Bearer $PROJECT_TOKEN" \
#          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$iid" | jq -r '.merge_status')
#        
#        if [ "$merge_status" = "merged" ]; then
#        log_info "MR $iid —É—Å–ø–µ—à–Ω–æ —Å–ª–∏—Ç"
#        break
#        else
#        log_info "MR $iid –µ—â—ë –Ω–µ —Å–ª–∏—Ç, –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ $sleep_seconds —Å–µ–∫—É–Ω–¥ ($i/$max_retries)"
#        sleep $sleep_seconds
#        fi
#        
#        # –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø–æ–ø—ã—Ç–∫–∏
#        if [ "$i" -eq "$max_retries" ]; then
#        log_info "MR $iid –Ω–µ –±—ã–ª —Å–ª–∏—Ç –∑–∞ –æ—Ç–≤–µ–¥—ë–Ω–Ω–æ–µ –≤—Ä–µ–º—è"
#        exit 1
#        fi
#        done