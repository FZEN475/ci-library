
#include:
##  - local: 'templates/-0-tests-rules/template.yml'
##    inputs:
##      test-pattern: '/^\d+\.\d+\.\d+$/'
#
#  - local: 'templates/auto-gitlab/template.yml'
#    inputs:
#      auto-rebase: true
#      auto-approve: true
#
#      auto-merge: true
#      auto-remove-source-branch: true
#
#      auto-tag: true
#      auto-tag-pattern: '/^\d+\.\d+\.\d+$/'
#      auto-tag-version-major: 0
#      auto-tag-version-minor: 4
#
#      auto-release: true
#      extra-needs-jobs:
#        - job: test-assets
#
variables:
  CI_DEBUG_TRACE: "true"
  AUTO_TAG_VERSION_MAJOR: 0
  AUTO_TAG_VERSION_MINOR: 4
  
#
#stages:
#  - commit-rules-test
#  - combine-rules-test
#  - auto-merge
#  - auto-release
#
#
#test-assets:
#  stage: auto-merge
#  cache:
#    - key: "$ARTIFACTS_DIR"
#      paths:
#        - "$ARTIFACTS_DIR"
#  script:
#    - mkdir -p "$ARTIFACTS_DIR"
#    - echo "Test" > "$ARTIFACTS_DIR/test.txt"
#    - |
#      {
#        echo "docker_image=docker_image"
#        echo "docker_image_digest=docker_image_digest"
#        echo "docker_repository=docker_repository"
#        echo "docker_tag=docker_tag"
#        echo "docker_digest=docker_digest"
#      } > docker.env
#  artifacts:
#    reports:
#      dotenv:
#        - docker.env

include:
  - local: 'templates/-1-common-rules/template.yml'

stages:
  - generator
  - release

.gitlab-api-tags-test: |
  api_get_tags() {
    local token="${1:?Не передан токен авторизации}"
    local search="${2:-}"  # Можно передавать фильтр
  
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
  
    local api_url="$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/tags"
    
    tag_list=$(curl -s -f -X GET \
      -H "Authorization: Bearer ${token}" \
      --data-urlencode "order_by=version" \
      --data-urlencode "sort=desc" \
      $( [ -n "$search" ] && echo "--data-urlencode search=$search" ) \
      "$api_url")
  
    echo "$tag_list"
  }
  
  get_last_release_tag() {
    local tags_json="${1:-[]}"
    echo "$tags_json" | jq -r 'if type=="array" and length>0 then .[0] else empty end'
  }
  
  get_patch_from_tag() {
    local tag="$1"
  
    # Убираем "v" в начале, если есть
    tag="${tag#v}"
  
    # Разбиваем на части
    set -- $(echo "$tag" | tr '.' ' ')
    local major="$1"
    local minor="$2"
    local patch="$3"
  
    # Проверяем, что patch — число
    case "$patch" in
      ''|*[!0-9]*) patch=0 ;;
    esac
  
    echo "$patch"
  }

  get_next_tag() {
    local token="${1:?Не передан токен авторизации}"
  
    : "${CI_API_V4_URL:?Не задана переменная CI_API_V4_URL}"
    : "${CI_PROJECT_ID:?Не задана переменная CI_PROJECT_ID}"
    : "${CI_DEFAULT_BRANCH:?Не задана переменная CI_DEFAULT_BRANCH}"
  
    # Получаем теги с нужным мажором и минором, отсортированные по версии (desc)
    TAGS_JSON=$(api_get_tags "$token" "${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}." | tr -d '\r' )
  
    printf '%s\n' "$TAGS_JSON" | jq . >&2
  
    LAST_TAG=$(get_last_release_tag "$TAGS_JSON")

    log_info "$LAST_TAG" >&2
  
    if [ -z "$LAST_TAG" ]; then
      patch=0
      ref="$CI_DEFAULT_BRANCH"
    else
      patch=$(get_patch_from_tag "$(echo "$LAST_TAG" | jq -r '.name')")
      patch=$((patch + 1))
      ref="$CI_COMMIT_SHA"
    fi

    # Формируем имя нового тега
    echo "${AUTO_TAG_VERSION_PREFIX}${AUTO_TAG_VERSION_MAJOR}.${AUTO_TAG_VERSION_MINOR}.${patch}"
  }

package-example:
  stage: generator
  extends: [ .package-cache, .release-package-template ]
  before_script:
    - !reference [ .install-utility ]
  parallel:
    matrix:
      - PACKAGE_FILE: "package/file1"
      - PACKAGE_FILE: "package/file2"
  script:
    - |
      {
        echo "release_package_name=$PACKAGE_FILE"
        echo "release_package_url=${CI_SERVER_URL}/${PACKAGE_FILE}"
        echo "release_package_link_type=other"
        echo "release_package_direct_asset_path=${PACKAGE_FILE}"
      } > after_script.env
    
        
#docker-example:
#  stage: generator
#  extends: [ .package-cache, .release-docker-template ]
#  before_script:
#    - !reference [ .install-utility ]
#  parallel:
#    matrix:
#      - DOCKER_REPO: "${CI_REGISTRY}/${CI_PROJECT_PATH}/example_1"
#        DOCKER_TAG: "0.0.1"
#      - DOCKER_REPO: "${CI_REGISTRY}/${CI_PROJECT_PATH}/example_2"
#        DOCKER_TAG: "0.0.1"
#  script:
#    - |
#      {
#        echo "release_docker_repository=${DOCKER_REPO}"
#        echo "release_docker_tag=${DOCKER_TAG}"
#      } > after_script.env


#    - |
#      echo release_asset_${CI_NODE_INDEX}="$DOCKER_FILE"
#    - |
#      assets_json=$(jq -n \
#      --arg name "$DOCKER_FILE" \
#      --arg url "$CI_PROJECT_URL" \
#      --arg link_type "image" \
#      --arg direct_asset_path "/${DOCKER_FILE}" \
#      '{"name": $name, "url": $url, "link_type": $link_type, "direct_asset_path": $direct_asset_path}' | jq -R -s '.'
#      )
#    - echo "$assets_json"
#    - echo "$assets_json" | jq -r '.'
#    - |
#      {
#        echo release_asset_${CI_NODE_INDEX}=$assets_json
#      } > release_asset.env
#  artifacts:
#    reports:
#      dotenv:
#        - release_asset.env

release_job:
  stage: release
  image: registry.gitlab.com/gitlab-org/cli:latest
  extends: [ .package-cache ]
  before_script:
    - !reference [ .install-utility ]
    - !reference [ .gitlab-api-tags-test ]
    - export test_tag=$(get_next_tag "$CI_JOB_TOKEN")
    - env
  rules:
    - if: '$CI_COMMIT_TAG == null'
  script:
    - |
      echo "$test_tag"
    - |
      cat > desc.md <<EOF
      Автоматический релиз для $test_tag  
      [Последний релиз](${CI_PROJECT_URL}/-/releases/permalink/latest)    
      EOF
    - ls -all ./
    - cat ./desc.md
    - |
      release_notes_list=$(env | awk -F= '/^release_notes_/ {print $1}')
      if [ -n "$release_notes_list" ]; then
        echo "---  " >> desc.md
        echo "### Docker образы  " >> desc.md
        for release_note_name in $release_notes_list; do
            eval "release_note_string=\$$release_note_name"
            echo "$release_note_string" | jq -r 'fromjson | .head // empty' >> desc.md
            echo "$release_note_string" | jq -r 'fromjson | .image // empty' >> desc.md
            echo "$release_note_string" | jq -r 'fromjson | .latest // empty' >> desc.md
        done
      fi

    - |
      assets_list_raw=$(env | awk -F= '/^release_asset_/ {print $1}')
      if [ -n "$release_notes_list" ]; then
        assets_list_json=$({
            for asset_value_name in $assets_list_raw; do
                eval "asset_value_string=\$$asset_value_name"
                echo "$asset_value_string" | jq -r '.'
            done
        } | jq -s '.' )
      else
        assets_list_json="[]"
      fi
    - echo "$assets_list_json"
    - |
      if echo "$assets_list_json" | jq -e 'length > 0' > /dev/null; then
        echo "---  " >> desc.md
        echo "### Последние версии пакетов  " >> desc.md
        echo "$assets_list_json" | jq -r '.[] | "- [\(.name)](\(env.CI_PROJECT_URL)/-/releases/permalink/latest/downloads\(.direct_asset_path))"' >> desc.md
      fi
    - |
      glab auth login --hostname "$CI_SERVER_HOST" --job-token "$CI_JOB_TOKEN"
      glab release create "$test_tag" --name "Release $test_tag" -F desc.md --ref "$CI_COMMIT_SHA" \
        --assets-links="$assets_list_json"
#  release:
#    tag_name: $CI_COMMIT_TAG
#    name: 'Release $CI_COMMIT_TAG'
#    description: 'Release created using the CLI.'


#spec:
#  inputs:
#    merge_branch_action:
#      options: ['skip', 'delete']
#      type: string
#      default: 'skip'
#    docker_builder:
#      type: boolean
#      default: false
#    helm_builder:
#      type: boolean
#      default: false
#    gradle_builder:
#      type: boolean
#      default: false
#    ansible_collection_build:
#      type: boolean
#      default: false
#    release_version:
#      type: string
#      default: ''
#---
#workflow:
#  auto_cancel:
#    on_job_failure: all
#
#stages:
#  - test_code
#  - build
#  - test_build
#  - deploy
#  - test_deploy
#  - final
#
#debug:job:
#  stage: test_code
#  script:
#    - 'sleep 1'
#  rules:
#    - if: $CI_DEBUG_TRACE == "true"
#      when: always
#    - when: never
#
#docker_builder:trigger:
#  stage: build
#  trigger:
#    include:
#      - project: 'library/ci'
#        ref: 'main'
#        file: 'docker_build/.gitlab-ci.yaml'
#    strategy: depend
#  rules:
#    - if: '"$[[ inputs.docker_builder ]]" == "true"'
#      when: always
#    - when: never
#
#helm_builder:trigger:
#  stage: build
#  variables:
#    MERGE_BRANCH_ACTION: "$[[ inputs.merge_branch_action | expand_vars ]]"
#  trigger:
#    include:
#      - project: 'library/ci'
#        ref: 'main'
#        file: 'helm_build/.gitlab-ci.yaml'
#    strategy: depend
#  rules:
#    - if: '"$[[ inputs.helm_builder ]]" == "true"'
#      when: always
#    - when: never
#
#gradle_builder:trigger:
#  stage: build
#  trigger:
#    include:
#      - project: 'library/ci'
#        ref: 'main'
#        file: 'gradle_build/.gitlab-ci.yaml'
#    strategy: depend
#  rules:
#    - if: '"$[[ inputs.gradle_builder ]]" == "true" && $CI_COMMIT_TAG'
#      when: always
#    - when: never
#
#ansible_collection_build:trigger:
#  stage: build
#  trigger:
#    include:
#      - project: 'library/ci'
#        ref: 'main'
#        file: 'ansible_collection_build/.gitlab-ci.yaml'
#    strategy: depend
#  rules:
#    - if: '"$[[ inputs.ansible_collection_build ]]" == "true" && $CI_COMMIT_REF_PROTECTED == "true"'
#      when: always
#    - when: never
#
#release:trigger:
#  stage: final
#  variables:
#    GRADLE_BUILDER: "$[[ inputs.gradle_builder ]]"
#  trigger:
#    include:
#      - project: 'library/ci'
#        ref: 'main'
#        file: 'release/.gitlab-ci.yaml'
#    strategy: depend
#  rules:
#    - if: '$CI_COMMIT_TAG'
#      when: always
#    - when: never
#
#auto_merge:trigger:
#  stage: final
#  variables:
#    MERGE_BRANCH_ACTION: "$[[ inputs.merge_branch_action | expand_vars ]]"
#  trigger:
#    include:
#      - project: 'library/ci'
#        ref: 'main'
#        file: 'auto_merge/.gitlab-ci.yaml'
#    strategy: depend
#  needs:
#    - job: docker_builder:trigger
#      optional: true
#  rules:
#    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#      when: always
#    - when: never
